syntax = "proto3";

import "google/protobuf/timestamp.proto";

service Management {
    rpc CreateTask(CreateTaskRequest) returns (CreateTaskResult);
    rpc ListTask(ListTaskRequest) returns (ListTaskResult);
    rpc ListWorker(ListWorkerRequest) returns (ListWorkerResult);
}

message CreateTaskRequest {
    oneof task {
        TaskCollectDisk task_collect_disk = 4;
        TaskCollectMemory task_collect_memory = 5;
    }
    bytes target = 1;
}

message TargetSelector {

}

message CreateTaskResult {
    bytes uuid = 1;
}

message ListTaskRequest {

}

message ListTaskResult {
    repeated ListTask tasks = 1;
}

message ListTask {
    bytes uuid = 1;
    enum TaskStatus {
        WAITING = 0;
        RUNNING = 1;
        COMPLETE = 2;
    }
    TaskStatus status = 2;
    google.protobuf.Timestamp created_at = 3;
    google.protobuf.Timestamp assigned_at = 4;
    google.protobuf.Timestamp completed_at = 5;

    bytes target = 6; // Target UUID
    oneof task {
        TaskCollectDisk task_collect_disk = 7;
        TaskCollectMemory task_collect_memory = 8;
    }

    bytes worker = 9; // Worker UUID
}

message ListWorkerRequest {

}

message ListWorkerResult {
    bytes uuid = 1;
    string hostname = 2;
}

service WorkerTasks {
    rpc Session(stream SessionResults) returns (stream SessionEvents);
}

message SessionResults {
    oneof result {
        WorkerRegistration worker_registration = 1;
        WorkerTaskResult worker_task_result = 2;
    }
}

message SessionEvents {
    oneof event {
        WorkerAcceptance worker_acceptance = 1;
        WorkerTask worker_task = 2;
    }
}

message WorkerRegistration {
    optional bytes previous_uuid = 1;
    string hostname = 2;
}

message WorkerAcceptance {
    bytes uuid = 1;
}

message WorkerTask {
    bytes uuid = 1;
    optional Target target = 2;
    oneof task {
        TaskNone task_none = 3;
        TaskCollectDisk task_collect_disk = 4;
        TaskCollectMemory task_collect_memory = 5;
    }
}

message Target {
    bytes uuid = 1;
    oneof access {
        SSHAccess ssh = 2;
    }
}

message SSHAccess {
    string host = 1;
    string user = 2;
    uint32 port = 3;
    string private_key = 4;
    // sudo
    bool become = 5;
    string become_password = 6;
}

message WorkerTaskResult {
    bytes uuid = 1;
    oneof task {
        TaskNoneResult task_none = 2;
        TaskCollectDiskResult task_collect_disk = 3;
        TaskCollectMemoryResult task_collect_memory = 4;
    }
}

message TaskNone {

}

message TaskNoneResult {

}

message TaskCollectDisk {
    CollectDiskSelector selector = 2;
}

message TaskCollectDiskResult {

}

message CollectDiskSelector {
    enum Group {
        ALL_DISKS = 0;
        ROOT_DISK = 1;
        ROOT_PARTITION = 2;
    }
    Group group = 1;
}

message TaskCollectMemory {

}

message TaskCollectMemoryResult {

}

// vim: set et ts=4 sw=4:
